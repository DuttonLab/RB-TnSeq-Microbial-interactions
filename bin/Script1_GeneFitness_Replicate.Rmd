---
title: "Script1_GeneFitness_Replicate"
author: "Manon Morin"
date: "6/29/2020"
output: html_document
---
##**STEP 1:Gene fitness values and associated variance for 1 replicate of a set of RB-TnSeq experiments (Same T0)**  

## Script: Script1_GeneFitness_Replicate.Rmd
       

That script processes the raw counts data from the allpoolcounts.tab file generated by the perl script BarSeqTest.pl (Wetmore **et al.**, 2015).
This script processes 1 biological replicate
This script produces a final file containing normalized gene fitness and associated fitness variance. 
Plots are generated during data processing to visually follow data transformation.
<br>


### Run

#### Packages and functions 

```{r setup, include=TRUE, warning=FALSE}
rm(list=ls())

# Step 1: Packages

library(ggplot2)
library(dplyr)
library(tidyr)
library(gridExtra)


# Step 2: Sourcing functions required in that script
source("Data_prep_viz10KB.R")
source("Ref_counts_CorrandNorm.R")
source("Gene_fitness.R")
source("Loc_smoothmed_norm.R")
```
<br>


#### Input data and parameters set up

```{r, include=TRUE,  warning=FALSE}
# Step 3: Parameters set up and data import

 #Different parameters have to be defined by the user:
  # org_locId: depending on your genome annotations, the locus_Id may be numerics or characters
  # cdnb: number of analyzed conditions (including T0) 
  # scaffold: Set up the chromosome scaffold (for plot purposes only)
  # Indicate the locusId of the gene you will use as a reference to normalize counts

org_locId=""   # "Num" if numeric , "Char" if characters
cdnb=
scaffoldX=  
ref=c() # here you write the locusId of your reference gene CAREFUL, depending on the locusId Type, it might be a numeric  or character 

 # You need to import the table containing the number of counts per barcodes in each condition (allpoolcounts.tab transformed as a csv file - make sure to keep all columns)
 # The first 7 columns of your table should be: barcodes, rbarcode, scaffold, strand, pos, locusId and f, then each column should be a condition ==> THIS IS IMPORTANT THAT THE FIRST 7 COLUMNS ARE NOT COUNTS
 # ALSO COLUMN 8 MUST BE NAMED T0
 # THE CONDITIONS MUST HAVE THE SAME NAME IN EACH REPLICATE
 # You also need to import the genes.GC (as a .txt file) file used to run the perl script TestBarSeq.pl (Wetmore et al., 2015). 

Data_original=read.csv(".csv")  # import your allpoolcounts file

genes.tab <- readr::read_delim("genes.GC.txt", 
                               "\t", escape_double = FALSE, trim_ws = TRUE)  # import your gene.GC file

```
<br>


#### Original data visualization

```{r, include=TRUE, echo=TRUE, warning=FALSE}
# Step 4: Data pre-visualization

 # Before processing the data we represent, for each condition (T0 included) the number of counts per 10kB and the distribution of number of counts per insertion mutant

Data=Data_original

    # Number of counts per 10kB

Data_prep=Data_prep_viz10KB(Data,cdnb,scaffoldX)    # format the data for vizualisation as counts per 10kB

dat_format <- data.frame(Data_prep[ncol(Data_prep)], stack(Data_prep[1:cdnb]))
colnames(dat_format)=c("Rank","Counts","Cdt")

plot1=ggplot(dat_format, aes(x=Rank,y=Counts,col=Cdt)) + geom_point(shape=19) +
  theme(axis.text.x = element_text(size=5),axis.text.y = element_text(size=5)) + 
  ggtitle("Counts per 10kb interval") +
  facet_grid(Cdt ~ .) + labs(x = "Chromosome position (10kB)", y="Counts per 10kb interval")

#Note:if a couple of outliers points prevent from accuretely observing the number of counts per 10kB, you can change y=Counts to y=log10(Counts)

# Distribution of number of counts per insertion mutant

Data_distr=gather(Data,"Cond","Counts",T0:ncol(Data))

plot1a=ggplot(Data_distr, aes(x=Counts,col=Cond)) + geom_density() + 
  theme(axis.text.x = element_text(size=5),axis.text.y = element_text(size=5)) +
  ggtitle("Distribution of counts per insertion mutant") +
  facet_grid(Cond ~ .) + labs(x = "Counts per insertion mutant")



grid.arrange(plot1, plot1a, nrow=2)   
```
<br>


#### Selection of insertion mutants, followed by counts correction and normalization

Selection: raw counts have to be processed prior to fitness calculation. Insertion mutants in intergenic regions and that are located outside of the ORF (f<0.1 and f>0.9) are filtered out. Also, any mutants with a low abundance in the T0 condition are filtered out.

Count correction: a pseudocount of .1 is added to all counts to avoid counts of 0

Normalization: corrected counts are normalized by the average number of reads per insertion mutant calculated using a set of reference genes associated with neutral fitness in all tested conditions

```{r, include=TRUE, echo=TRUE, warning=FALSE}
# Step 5: Count correction before fitness calculation

 # A pseudocount of .1 is added to each count to avoid counts of 0
 # Insertions mutants that are outside of the ORF (f<0.1 and f>0.9) are filtered out
 # Insertion mutants that do not pass the T0 count threshold (before correction relative to reference ; Counts<3.1) are filtered out
 # Counts are normalized using at least one reference gene (no fitness effect in all tested conditions) - The reference are used to calculate the average number of read per insertion mutant which is in turn used for normalization
 # Data are visualized again after correction (Number of corrected counts per 10kb and Distribution of corrected counts)

  # The function Data_counts_CorrandNorm perform all the aformentioned modifications
Data_ref_corrected=Ref_counts_CorrandNorm(Data, ref, cdnb)

  # Number of corrected counts per 10kB
Dat_viz=Data_prep_viz10KB(Data_ref_corrected,cdnb,scaffoldX)
dat_format <- data.frame(Dat_viz[ncol(Dat_viz)], stack(Dat_viz[1:cdnb]))
colnames(dat_format)=c("Rank","Counts","Cdt")

plot2=ggplot(dat_format, aes(x=Rank,y=Counts,col=Cdt)) + geom_point(shape=19) + 
  theme(axis.text.x = element_text(size=5),axis.text.y = element_text(size=5)) + ggtitle("Corrected counts per 10kb interval") +
  facet_grid(Cdt ~ .) + labs(x = "Chromosome position (10kB)", y="Counts per 10kb interval")

#Note:if a couple of outliers points prevent from accuretely observing the number of counts per 10kB, you can change y=Counts to y=log10(Counts)

  # Distribution of number of counts per insertion mutant

Data_distr=gather(Data_ref_corrected,"Cond","Counts",T0:ncol(Data_ref_corrected))

plot2a=ggplot(Data_distr, aes(x=Counts,col=Cond)) + geom_density() + 
  theme(axis.text.x = element_text(size=5),axis.text.y = element_text(size=5)) +
  ggtitle("Distribution of corrected counts per insertion mutant") +
  facet_grid(Cond ~ .) + labs(x = "Counts per insertion mutant after correction and normalization")



grid.arrange(plot2, plot2a, nrow=2)  
```

<br>

####Calculation of gene fitness values

A gene fitness value is calculated as the average of the fitness values of associated insertion mutants. The fitness of insertion mutants is the log2 of the ratio of the insertion mutantâ€™s normalized counts in a given condition and at T0.

```{r, include=TRUE, echo=TRUE, warning=FALSE}
# Step 6: Calculation of gene fitness
 # Calculation of the strain fitness (fitness for each insertion with central insertion as the log2 of the ratio of the corrected counts in the condition and the corrected counts in the T0)
 # Calculation of gene fitness values along with associated variance (average of all the insertion mutants fitness in that gene)
 # Vizualization of the gene fitness values (along the chromose (plot3) or as a distribution (plot4))

Data_for_fit=Data_ref_corrected
cdnbF=(cdnb-1)   # number of conditions for which we will get a fitness values (=everything but T0)

# The following function returns a list containing 3 tables: "Strain fitness": strain fitness values, "Gene_fitness": unnormalized gene fitness values and "Gene_fitness_variance": variance assocaited with gene fitness values 

Raw_values=Gene_fitness(Data_for_fit,cdnbF,genes.tab,org_locId)  

Table_GeneFitness_Raw=Raw_values[[2]]  # We extract the table with the unnormalized fitness values for data vizualisation

 #We format the data to vizualise them 
dat_format <- data.frame(Table_GeneFitness_Raw[1], Table_GeneFitness_Raw[(ncol(Table_GeneFitness_Raw)-1):ncol(Table_GeneFitness_Raw)], stack(Table_GeneFitness_Raw[2:(2+cdnbF-1)]))
colnames(dat_format)=c("locusId","sysName","begin","RawFitness","Cdt")

plot3=ggplot(dat_format, aes(x=begin,y=RawFitness,col=Cdt)) + geom_point(shape=19) + 
  theme(axis.text.x = element_text(size=5),axis.text.y = element_text(size=5)) + ggtitle("Unnormalized gene fitness") +
  facet_grid(Cdt ~ .) + labs(x = "Chromosome position", y="Fitness value")

plot4=ggplot(dat_format, aes(x=RawFitness,col=Cdt)) + geom_density(aes(fill=Cdt)) + 
  theme(axis.text.x = element_text(size=5),axis.text.y = element_text(size=5))+ ggtitle("Distribution of gene unnormalized fitness values") +
  facet_grid(Cdt ~ .) + labs(x = "Fitness value", y="Density")


grid.arrange(plot3, plot4, ncol=1)
```
<br>

#### Chromosome position normalization of gene fitness values

As described in Wetmore *et al.*, 2015, gene fitness values are normalized based on the gene location on the chromosome using the smoothed median.

```{r, include=TRUE, echo=TRUE, warning=FALSE}

# Step 7: Gene fitness normalization
 # Normalize gene fitness based on the position of the gene on the chromosome (smooth median normalization ; Wetmore et al., 2015)
 # Data visualization like Step 6

Data_to_norm=Table_GeneFitness_Raw
Data_norm_loc=Loc_smoothmed_norm(Data_to_norm,genes.tab,cdnbF,org_locId)  # we obtain the gene fitness values normalized by the smoothed median ==> normalization for gene location


 # Data visualization
dat_format <- data.frame(Data_norm_loc[1:4], stack(Data_norm_loc[5:ncol(Data_norm_loc)]))
colnames(dat_format)=c("locusId","sysName","begin","scaffold","NormFitness","Cdt")
dat_format$begin=as.numeric(dat_format$begin)
dat_format$NormFitness=as.numeric(dat_format$NormFitness)

plot5=ggplot(dat_format, aes(x=begin, y=NormFitness, col=Cdt)) + geom_point(shape=19)+
  theme(axis.text.x = element_text(size=5),axis.text.y = element_text(size=5)) + ggtitle("Normalized gene fitness values (smoothed median)") +
  facet_grid(Cdt ~ .) + labs(x = "Chromosome position (10kB)", y="Fitness value")

plot6=ggplot(dat_format, aes(x=NormFitness, col=Cdt)) + geom_density(aes(fill=Cdt)) +
  theme(axis.text.x = element_text(size=5),axis.text.y = element_text(size=5)) + ggtitle("Distribution normalized gene fitness values (smoothed median)") + facet_grid(Cdt ~ .) + labs(y = "Density", x="Fitness value")

grid.arrange(plot5, plot6, ncol=1)
```
<br>

#### Saving data

```{r, include=TRUE, echo=TRUE, warning=FALSE}

# Step 8: Data formating and save

  # Data formating

Data_Fitness_Replicate=dat_format

Table_GeneFitness_VAR=Raw_values[[3]]
Data_Fitness_VAR=data.frame(Table_GeneFitness_VAR[1],
                            stack(Table_GeneFitness_VAR[2:ncol(Table_GeneFitness_VAR)]))
colnames(Data_Fitness_VAR)=c("locusId","Fitness_Variance","Cdt")


if (org_locId=="Num"){
  Data_Fitness_Replicate$locusId=as.numeric(Data_Fitness_Replicate$locusId)
}

All_data_Replicate=left_join(Data_Fitness_Replicate,Data_Fitness_VAR,by=c("locusId","Cdt"))
All_data_Replicate=All_data_Replicate[c(1,2,3,4,6,5,7)]


save(All_data_Replicate, Data_norm_loc,
     Raw_values, Data_ref_corrected, Data_original, genes.tab,
     file=".RData")

```
